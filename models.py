"""SQLModel definitions for Chorus - Task-Centric Claude Session Orchestrator."""

from datetime import datetime, timezone
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from sqlmodel import Field, SQLModel


class TaskStatus(str, Enum):
    """Task lifecycle status."""
    pending = "pending"      # Task created, not yet started (no tmux, no stack)
    running = "running"      # tmux process active, Claude is working
    waiting = "waiting"      # Claude is asking for permission
    completed = "completed"  # Task finished, changes committed via GitButler
    failed = "failed"        # Task failed or was cancelled


class ClaudeStatus(str, Enum):
    """Claude session status within a task's tmux process."""
    stopped = "stopped"      # Claude not running in tmux (can be restarted)
    starting = "starting"    # Claude is initializing
    idle = "idle"            # Claude at prompt, waiting for input
    busy = "busy"            # Claude is processing
    waiting = "waiting"      # Claude asking for permission


class DocumentCategory(str, Enum):
    """Document category enum."""
    instructions = "instructions"
    plans = "plans"
    communication = "communication"
    context = "context"
    general = "general"


class Task(SQLModel, table=True):
    """A unit of work with its own tmux process and GitButler stack.

    This is the primary entity in Chorus. Each task:
    - Has a UUID that serves triple duty: Task ID, Claude session_id, GitButler session identifier
    - Runs in its own tmux process for isolation
    - Is attached to a GitButler auto-created stack (discovered after first file edit)
    - Can have multiple Claude sessions (restartable with --resume)
    """
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    title: str
    description: str = Field(default="")
    priority: int = Field(default=0)
    status: TaskStatus = Field(default=TaskStatus.pending)

    # GitButler integration (auto-discovered after first file edit)
    stack_cli_id: Optional[str] = Field(default=None)    # CLI ID, e.g., "u0", discovered via hooks
    stack_name: Optional[str] = Field(default=None)      # Auto-created name, e.g., "zl-branch-15"

    # tmux process
    tmux_session: Optional[str] = Field(default=None)  # e.g., "task-{uuid}"
    ttyd_port: Optional[int] = Field(default=None)  # Web terminal port (assigned when task starts)

    # Claude session state (ephemeral, can be restarted)
    # Note: task.id (UUID) is used for GitButler hooks (persistent)
    # claude_session_id is used for Claude's --resume (changes on restart)
    claude_session_id: Optional[str] = Field(default=None)  # For --resume, changes on Claude restart
    claude_status: ClaudeStatus = Field(default=ClaudeStatus.stopped)
    claude_activity: Optional[str] = Field(default=None)  # Current activity description (e.g., "Editing main.py")
    claude_restarts: int = Field(default=0)
    continuation_count: int = Field(default=0)  # How many times task was continued with new prompts
    prompt_history: str = Field(default="")  # JSON array of prompts sent to Claude
    last_output: str = Field(default="")  # Last ~10000 chars of formatted log output
    permission_prompt: Optional[str] = Field(default=None)

    # Permission policy (task-specific, enforced via PermissionRequest hooks)
    permission_policy: str = Field(default="")  # JSON object with allowed tools, patterns, auto-approve rules

    # Timestamps
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    started_at: Optional[datetime] = Field(default=None)  # When tmux was spawned
    completed_at: Optional[datetime] = Field(default=None)

    # Completion info (commit messages auto-generated by GitButler)
    result: Optional[str] = Field(default=None)  # Completion notes or failure reason


class Document(SQLModel, table=True):
    """A tracked markdown file in the project."""
    id: Optional[int] = Field(default=None, primary_key=True)
    path: str = Field(unique=True)
    category: DocumentCategory = Field(default=DocumentCategory.general)
    description: Optional[str] = Field(default=None)
    pinned: bool = Field(default=False)
    last_modified: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class DocumentReference(SQLModel, table=True):
    """A reference to specific lines in a document, linked to a task."""
    id: Optional[int] = Field(default=None, primary_key=True)
    document_id: int = Field(foreign_key="document.id")
    task_id: UUID = Field(foreign_key="task.id")  # References Task.id (UUID)
    start_line: int
    end_line: int
    note: Optional[str] = Field(default=None)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class PermissionRequestStatus(str, Enum):
    """Permission request status."""
    pending = "pending"      # Waiting for user decision
    approved = "approved"    # User approved
    denied = "denied"        # User denied
    timeout = "timeout"      # Request timed out


class PermissionRequest(SQLModel, table=True):
    """A permission request from Claude that needs web UI approval."""
    id: Optional[int] = Field(default=None, primary_key=True)
    task_id: UUID = Field(foreign_key="task.id")
    tool_name: str
    tool_input: str  # JSON string of tool input parameters
    status: PermissionRequestStatus = Field(default=PermissionRequestStatus.pending)
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    decided_at: Optional[datetime] = Field(default=None)
